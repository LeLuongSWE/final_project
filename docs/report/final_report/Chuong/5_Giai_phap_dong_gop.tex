\documentclass[../20232006p.tex]{subfiles}
\begin{document}


Chương này tập trung trình bày chi tiết các giải pháp trọng tâm và những đóng góp nổi bật về mặt công nghệ cũng như quy trình nghiệp vụ mà đồ án đã đạt được. Xuất phát từ những thách thức đặc thù của mô hình kinh doanh nhà hàng cơm bình dân—nơi có áp lực thời gian phục vụ cực lớn trong khung giờ cao điểm và sự biến động liên tục của thực đơn hàng ngày—chúng tôi đã nghiên cứu và áp dụng các chiến lược thiết kế hệ thống chuyên biệt. Những giải pháp này không chỉ dừng lại ở việc đáp ứng các yêu cầu chức năng cơ bản mà còn đi sâu giải quyết các bài toán về tối ưu hóa hiệu năng, đảm bảo tính toàn vẹn dữ liệu tài chính và nâng cao trải nghiệm người dùng cuối. Các nội dung dưới đây sẽ phân tích sâu sắc cách thức hệ thống vượt qua các rào cản kỹ thuật để đạt được sự ổn định và hiệu quả trong môi trường vận hành thực tế.

\section{Cơ chế quản lý thực đơn động và kiểm soát phiên bán hàng}

Một trong những vấn đề nan giải nhất mà các chủ cửa hàng cơm bình dân gặp phải là sự thay đổi liên tục của thực đơn. Nguồn nguyên liệu phụ thuộc vào chợ đầu mối khiến danh sách món ăn mỗi ngày không cố định. Các hệ thống POS thông thường quản lý thực đơn theo một danh sách tĩnh (Static List), buộc người quản lý phải thực hiện rất nhiều thao tác thêm, sửa, xóa mỗi ngày để cập nhật tình trạng món. Điều này không chỉ tốn thời gian mà còn dễ gây ra sai sót, dẫn đến việc nhân viên thu ngân chọn nhầm món không có thực trong ngày hôm đó.

Để giải quyết vấn đề này, đồ án đã đề xuất kiến trúc quản lý thực đơn hai cấp độ: Kho dữ liệu tổng thể (Master Data) và Thực đơn theo phiên (Session Menu). Ở cấp độ thứ nhất, hệ thống lưu trữ toàn bộ các món ăn mà nhà hàng có thể nấu, bao gồm hình ảnh, công thức định lượng và giá tham chiếu. Ở cấp độ thứ hai, vào đầu mỗi ngày làm việc, người quản lý chỉ cần thực hiện thao tác ``lên thực đơn'' bằng cách chọn một tập hợp con từ kho dữ liệu tổng thể. Hệ thống hỗ trợ cơ chế sao chép thực đơn từ ngày hôm trước hoặc sử dụng các mẫu thực đơn có sẵn (Menu Templates) để giảm thiểu tối đa thời gian thao tác. Khi một phiên bán hàng được kích hoạt, chỉ những món ăn nằm trong thực đơn phiên đó mới được tải xuống máy POS của thu ngân. Giải pháp này giúp giao diện bán hàng luôn gọn gàng, loại bỏ hoàn toàn các món không phục vụ, giúp nhân viên không mất thời gian tìm kiếm và giảm thiểu rủi ro gọi món sai. Hơn thế nữa, hệ thống còn hỗ trợ tính năng cập nhật trạng thái ``Hết hàng'' (Out of Stock) theo thời gian thực. Ngay khi nhà bếp báo hết một món cụ thể, quản lý có thể cập nhật trạng thái này và hệ thống sẽ tự động vô hiệu hóa nút bấm tương ứng trên toàn bộ các thiết bị POS đang hoạt động, ngăn chặn triệt để tình trạng bán quá số lượng thực tế.

\section{Tái thiết kế quy trình bán hàng Quick Serve và giao diện chạm}

Áp lực lớn nhất tại các quán cơm bình dân nằm ở khung giờ 11:30 đến 12:30, khi lưu lượng khách hàng tăng đột biến. Trong bối cảnh đó, mỗi giây thao tác thừa của thu ngân đều có thể dẫn đến ùn tắc cục bộ. Quy trình bán hàng truyền thống bao gồm các bước: Mở bàn, Chọn món, Gửi bếp, Chờ khách ăn xong, In tạm tính, và Thanh toán. Quy trình này quá cồng kềnh và không phù hợp với mô hình trả tiền trước hoặc thanh toán tại quầy của cơm bình dân.

Đồ án đã xây dựng quy trình bán hàng nhanh (Quick Serve Workflow) với triết lý ``Three-Click-Action'' (Thao tác trong ba lần chạm). Quy trình được rút gọn tối đa thành một luồng tuyến tính: Chọn món, Xác nhận, và Thanh toán. Để hiện thực hóa điều này, giao diện người dùng (UI) được thiết kế chuyên biệt cho màn hình cảm ứng (Touch-first Design). Thay vì sử dụng các danh sách dạng bảng (Table view) khó thao tác chính xác bằng ngón tay, hệ thống sử dụng lưới các nút bấm (Grid Layout) với kích thước lớn (tối thiểu 64x64 pixels). Màu sắc của các nút được mã hóa theo nhóm món ăn (ví dụ: món mặn màu đỏ, món rau màu xanh, đồ uống màu vàng) giúp nhân viên định vị món ăn theo phản xạ thị giác mà không cần đọc tên từng món. Các thao tác phụ trợ như thay đổi số lượng, thêm ghi chú cho bếp được thực hiện thông qua các cử chỉ vuốt hoặc nhấn giữ (Long press), giúp giữ cho màn hình chính luôn thoáng đãng. Thêm vào đó, hệ thống tích hợp sâu với máy in nhiệt. Ngay khi giao dịch được xác nhận thanh toán thành công, lệnh in được gửi trực tiếp xuống phần cứng mà không cần thông qua hộp thoại xác nhận in của trình duyệt, giúp khép kín quy trình phục vụ chỉ trong vòng dưới 30 giây cho mỗi lượt khách.

\section{Kiến trúc phân tầng và bảo mật với Data Transfer Object}

Hệ thống được xây dựng dựa trên nền tảng kiến trúc ba tầng (Three-tier Architecture) tiêu chuẩn, tuy nhiên đã được tinh chỉnh để tăng cường tính bảo mật và khả năng bảo trì. Sự phân tách rõ ràng giữa tầng Trình bày (Controller), tầng Nghiệp vụ (Service) và tầng Truy xuất dữ liệu (Repository) cho phép các thành phần phát triển độc lập và dễ dàng thay thế khi cần thiết. Điểm nhấn quan trọng trong kiến trúc này là việc áp dụng triệt để mẫu thiết kế Đối tượng chuyển dữ liệu (Data Transfer Object - DTO).

Trong các ứng dụng web thông thường, lập trình viên thường mắc lỗi trả về trực tiếp thực thể cơ sở dữ liệu (Entity) cho Client. Điều này tiềm ẩn rủi ro bảo mật nghiêm trọng khi để lộ cấu trúc bảng, các trường dữ liệu nhạy cảm (như mật khẩu, khóa bí mật) hoặc các thông tin nội bộ (như ngày tạo, người tạo). Đồ án giải quyết vấn đề này bằng cách quy định nghiêm ngặt việc mọi dữ liệu đi ra hoặc đi vào API đều phải thông qua DTO. Các lớp DTO đóng vai trò như một lớp bộ lọc (Filter layer), chỉ chứa các trường dữ liệu thực sự cần thiết cho giao diện người dùng. Việc này không chỉ tăng cường bảo mật mà còn giúp tối ưu hóa băng thông mạng bằng cách loại bỏ các dữ liệu dư thừa. Quá trình chuyển đổi (Mapping) giữa Entity và DTO được thực hiện tự động hóa bằng thư viện MapStruct, giúp giảm thiểu các đoạn mã lặp lại (Boilerplate code) và đảm bảo hiệu năng chuyển đổi gần như tương đương với mã viết tay nhờ cơ chế sinh mã tại thời điểm biên dịch (Compile-time).

\section{Cơ chế Snapshot dữ liệu đảm bảo tính toàn vẹn tài chính}

Một thách thức kỹ thuật quan trọng trong các hệ thống thương mại điện tử và bán lẻ là vấn đề lưu trữ lịch sử giá. Trong cơ sở dữ liệu quan hệ, nếu thiết kế không cẩn thận, việc cập nhật giá của một sản phẩm trong bảng danh mục (\texttt{products}) có thể vô tình làm thay đổi giá trị của tất cả các đơn hàng trong quá khứ tham chiếu đến sản phẩm đó. Điều này dẫn đến sự sai lệch nghiêm trọng trong báo cáo doanh thu và vi phạm các nguyên tắc kế toán.

Để giải quyết triệt để vấn đề này, đồ án đã triển khai kỹ thuật Snapshot dữ liệu (Data Snapshotting) hay còn gọi là Denormalization có chủ đích. Cụ thể, bảng \texttt{order\_items} (chi tiết đơn hàng) được thiết kế không chỉ chứa khóa ngoại tham chiếu đến sản phẩm, mà còn chứa một bản sao độc lập của các thuộc tính quan trọng tại thời điểm giao dịch, bao gồm: tên món ăn và đơn giá (\texttt{price\_at\_purchase}). Khi một đơn hàng được khởi tạo, hệ thống thực hiện logic nghiệp vụ sao chép giá trị hiện hành từ bảng sản phẩm sang bảng chi tiết đơn hàng. Nhờ đó, mỗi dòng trong bảng \texttt{order\_items} trở thành một bằng chứng lịch sử bất biến. Dù trong tương lai, sản phẩm có bị đổi tên, tăng giá, hay thậm chí bị xóa khỏi hệ thống (Soft delete), thì dữ liệu trong các đơn hàng cũ vẫn giữ nguyên giá trị ban đầu. Giải pháp này đảm bảo rằng khi truy xuất lại một hóa đơn từ 6 tháng trước, thông tin hiển thị hoàn toàn trùng khớp với thời điểm khách hàng thanh toán, đảm bảo tính chính xác tuyệt đối cho công tác đối soát và báo cáo tài chính.

\section{Chiến lược Caching đa tầng với Redis}

Với đặc thù hệ thống có tỷ lệ thao tác đọc dữ liệu (Read operation) chiếm áp đảo so với thao tác ghi (Write operation)—cụ thể là việc hàng loạt thiết bị POS liên tục tải danh sách thực đơn—việc truy vấn trực tiếp vào cơ sở dữ liệu quan hệ (RDBMS) như PostgreSQL sẽ tạo ra nút thắt cổ chai về hiệu năng (I/O Bottleneck). Để khắc phục, đồ án đã triển khai chiến lược Caching (Lưu trữ bộ nhớ đệm) sử dụng Redis.

Cơ chế Cache-aside (Lazy Loading) được áp dụng một cách linh hoạt. Khi có yêu cầu lấy thực đơn từ Client, hệ thống trước tiên sẽ kiểm tra trong Redis. Do Redis lưu trữ dữ liệu trên RAM với cấu trúc Key-Value tối ưu, thời gian phản hồi thường chỉ ở mức dưới 5 mili-giây. Nếu dữ liệu không tồn tại trong Cache (Cache Miss), hệ thống mới thực hiện truy vấn xuống cơ sở dữ liệu, sau đó lưu kết quả vào Redis trước khi trả về cho Client. Để đảm bảo tính nhất quán dữ liệu (Data Consistency), đồ án thiết kế cơ chế làm mất hiệu lực Cache (Cache Invalidation) dựa trên sự kiện. Ngay khi người quản lý thực hiện bất kỳ thao tác thay đổi nào đối với thực đơn (như cập nhật giá, đổi trạng thái món ăn), một sự kiện sẽ được kích hoạt để xóa ngay lập tức các khóa tương ứng trong Redis. Điều này đảm bảo rằng dù sử dụng bộ nhớ đệm để tăng tốc độ, nhưng người dùng cuối luôn nhìn thấy dữ liệu mới nhất mà không gặp phải tình trạng hiển thị thông tin cũ (Stale data). Kết quả thực nghiệm cho thấy giải pháp này giúp giảm tải cho cơ sở dữ liệu chính tới 85\% trong giờ cao điểm. \cite{redis}


\subsection{Hệ thống giao tiếp thời gian thực dựa trên WebSocket}

Để giải quyết bài toán đồng bộ thông tin tức thời giữa bộ phận thu ngân và bộ phận bếp, đồ án đã thay thế hoàn toàn cơ chế HTTP Polling truyền thống bằng giao thức WebSocket. Trong các hệ thống cũ, để biết có đơn hàng mới hay không, màn hình tại bếp phải liên tục gửi yêu cầu (Request) lên máy chủ sau mỗi vài giây. Điều này tạo ra một lượng lớn lưu lượng mạng dư thừa và độ trễ không thể tránh khỏi.

Đồ án sử dụng giao thức STOMP (Simple Text Oriented Messaging Protocol) chạy trên nền WebSocket để thiết lập kênh giao tiếp hai chiều liên tục (Full-duplex). Mô hình Publish-Subscribe được áp dụng: màn hình bếp đóng vai trò là Subscriber đăng ký nhận tin từ kênh chủ đề \texttt{/topic/kitchen}. Khi một đơn hàng được lưu thành công vào cơ sở dữ liệu, \texttt{OrderService} sẽ đóng vai trò là Publisher, đẩy một thông điệp chứa thông tin đơn hàng vào kênh này. Nhờ đó, thông tin đơn hàng xuất hiện trên màn hình bếp gần như ngay lập tức (Real-time) sau khi thu ngân bấm nút. Giải pháp này không chỉ tối ưu hóa tài nguyên máy chủ mà còn nâng cao đáng kể khả năng phối hợp nhịp nhàng giữa các bộ phận, một yếu tố sống còn đối với mô hình kinh doanh dịch vụ ăn uống. \cite{pimentel2012communicating}



\end{document}